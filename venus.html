<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    

      <script defer src="/_vercel/insights/script.js"></script>


    


</head>
<body style="margin: 0; overflow: hidden;">




    
    


    <script type="module">
    


    
    



// Scene setup
// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  3000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // âœ… makes it crisp on high-DPI screens
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Handle resizing (desktop + mobile)
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
});


// Lighting setup
const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
scene.add(ambientLight);
const sunLight = new THREE.PointLight(0xffffff, 2, 100);
sunLight.position.set(0, 0, 0);
scene.add(sunLight);

// Load Textures
const textureLoader = new THREE.TextureLoader();
const sunTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/MioJoester/Asset@main/2k_venus.jpg');
const spaceTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/MioJoester/Asset@main/8k_milkyway.jpg');
const asteroidTexture = textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Asteroid_243_Ida.jpg/640px-Asteroid_243_Ida.jpg');

// Create Sun
const sunMaterial = new THREE.MeshStandardMaterial({ map: sunTexture, emissiveIntensity: 1 });
const sunGeometry = new THREE.SphereGeometry(9, 64, 64);
const sun = new THREE.Mesh(sunGeometry, sunMaterial);
scene.add(sun);

// Background Space
const spaceGeometry = new THREE.SphereGeometry(2000, 128, 128);
const spaceMaterial = new THREE.MeshBasicMaterial({ map: spaceTexture, side: THREE.BackSide });
const spaceSphere = new THREE.Mesh(spaceGeometry, spaceMaterial);
scene.add(spaceSphere);

// Asteroid Belt
const asteroids = [];
function createAsteroidBelt() {
    const asteroidCount = 3;
    const innerRadius = 80;
    const outerRadius = 30;

    for (let i = 0; i < asteroidCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const distance = innerRadius + Math.random() * (outerRadius - innerRadius);
        const size = Math.random() * 0.5 + 0.1;

        const asteroidGeometry = new THREE.SphereGeometry(size, 16, 16);
        const asteroidMaterial = new THREE.MeshStandardMaterial({ map: asteroidTexture });

        const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
        asteroid.position.set(
            Math.cos(angle) * distance,
            (Math.random() - 0.5) * 2,
            Math.sin(angle) * distance
        );

        asteroids.push(asteroid);
        scene.add(asteroid);
    }
}
createAsteroidBelt();

// Planets Data
const planets = [];

const planetData = [
    { name: "Mercury", texture: "y.jpg", size: 0.0, distance: 10.8, speed: 20 },
    { name: "Venus", texture: "s.jpg", size: 0.0, distance: 15.4, speed: 15 },
    { name: "Earth", texture: "h.jpg", size: 0, distance: 26, speed: 10 },
    { name: "Mars", texture: "s.jpg", size: 0.0, distance: 36.4, speed: 8 },
    { name: "Jupiter", texture: "r.jpg", size: 0.0, distance: 141, speed: 4 },
    { name: "Saturn", texture: "8.jpg", size: 0, distance: 181, speed: 3, tilt: 5 }
];

planetData.forEach(data => {
    const texture = textureLoader.load(`https://cdn.jsdelivr.net/gh/MioJoester/Asset@main/${data.texture}`);
    const planet = new THREE.Mesh(new THREE.SphereGeometry(data.size, 64, 64), new THREE.MeshStandardMaterial({ map: texture }));
    scene.add(planet);
    planets.push({ mesh: planet, distance: data.distance, speed: data.speed, tilt: data.tilt || 0 });
});




const Sat = planets.find(p => p.distance === 181).mesh; 
const ringTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/MioJoester/Asset@main/8.png');
const ringGeometry = new THREE.RingGeometry(3, 5, 128);
const ringMaterial = new THREE.MeshBasicMaterial({ map: ringTexture, side: THREE.DoubleSide, transparent: true, alphaTest: 0.5 });
const SatRings = new THREE.Mesh(ringGeometry, ringMaterial);
SatRings.rotation.x = -Math.PI / 2;
Sat.add(SatRings);



//3d camera + Renderer
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.enablePan = true;
controls.screenSpacePanning = false;
controls.minDistance = 5;
controls.maxDistance = 1000;

// Zoom Focus on Click
let selectedPlanet = spaceSphere;
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener('click', (event) => {3
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(planets.map(p => p.mesh));

    if (intersects.length > 0) {
        selectedPlanet = intersects[0].object;
        controls.target.copy(selectedPlanet.position);
    }
});

controls.addEventListener('change', () => {
    if (selectedPlanet) {
        controls.target.copy(selectedPlanet.position);
    }
});

// Animation loop with Saturn's Tilted Orbit
function animate() {
    requestAnimationFrame(animate);

    const time = performance.now() * 0.0001;
    planets.forEach(planet => {
        const angle = time * planet.speed;
        let x = Math.cos(angle) * planet.distance;
        let z = Math.sin(angle) * planet.distance;
        let y = 0;

        // Apply tilt to Saturn's orbit
        if (planet.mesh === Sat) {
            let tiltRad = THREE.MathUtils.degToRad(planet.tilt);
            y = Math.sin(angle) * planet.distance * Math.sin(tiltRad);
            z = Math.sin(angle) * planet.distance * Math.cos(tiltRad);
        }

        planet.mesh.position.set(x, y, z);
    });

    controls.update();
    renderer.render(scene, camera);
}

animate();

// Handle window resize
window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
});


        // Function to create an orbit path


    </script>
</body>
</html>
